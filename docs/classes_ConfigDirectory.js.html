<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>classes/ConfigDirectory.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ConfigDirectory.html">ConfigDirectory</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigDirectory.html#contents">contents</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigDirectory.html#defaults">defaults</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigDirectory.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigDirectory.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ConfigFile.html">ConfigFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigFile.html#defaults">defaults</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigFile.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="ConfigFile.html#write">write</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="formats.BufferFormat.html">BufferFormat</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="formats.JSONFormat.html">JSONFormat</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="formats.RawFormat.html">RawFormat</a></span></li><li class="nav-heading">Namespaces</li><li class="nav-heading"><span class="nav-item-type type-namespace">N</span><span class="nav-item-name"><a href="formats.html">formats</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="formats.html#.register_format">register_format</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="formats.html#.set_default_format">set_default_format</a></span></li><li class="nav-heading">Interfaces</li><li class="nav-heading"><span class="nav-item-type type-interface">I</span><span class="nav-item-name"><a href="Format.html">Format</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Format.html#read">read</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Format.html#write">write</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#directory">directory</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#file">file</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">classes/ConfigDirectory.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y &amp;&amp; (t = op[0] &amp; 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) &amp;&amp; t.call(y), 0) : y.next) &amp;&amp; !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] &amp; 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 &amp;&amp; (!t || (op[1] > t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }
                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
var fs_1 = require("fs");
var path = require("path");
var ConfigFile_1 = require("./ConfigFile");
/**
 * Represents a configuration directory
 *
 * @class ConfigDirectory
 * @param { string } directory_path - Absolute path to directory
 * @param { ?Format } format - Format responsible for data and content transformation. Passed when initializing a new ConfigFile when reading
 */
var ConfigDirectory = /** @class */ (function () {
    function ConfigDirectory(directory_path, format) {
        this.directory_path = directory_path;
        this.format = format;
    }
    /**
     * Specify what and how each ConfigFile's format should default content when reading
     *
```ts
import * as mlc from "@aery/mlc";
    
const directory: mlc.ConfigDirectory = mlc.directory("configs", new mlc.formats.JSONFormat())
    .defaults({
        "config.json": {
            ip: "127.0.0.1",
            port: 1337
        }
    });
```
     *
     * @memberof ConfigDirectory
     * @instance
     * @function defaults
     * @param {} default_files - Content each ConfigFile's format should default to when reading
     * @param {} default_options - Options telling format how to default content when reading
     * @returns { ConfigDirectory } - This ConfigDirectory for chainability
     */
    ConfigDirectory.prototype.defaults = function (default_files, default_options) {
        this.default_files = default_files;
        this.default_options = default_options;
        return this;
    };
    /**
     * Returns an object of ConfigDirectory's ConfigFiles' and ConfigDirectory's contents
     *
     * @memberof ConfigDirectory
     * @instance
     * @function contents
     * @returns { object } - ConfigDirectory's ConfigFiles' and ConfigDirectory's contents
     */
    ConfigDirectory.prototype.contents = function () {
        var contents = {};
        if (this.files) {
            for (var file in this.files) {
                var config = this.files[file];
                if (config instanceof ConfigFile_1.ConfigFile) {
                    contents[file] = config.content;
                }
                else if (config instanceof ConfigDirectory) {
                    contents[file] = config.contents();
                }
            }
        }
        return contents;
    };
    /**
     * Reads directory's files and sets ConfigFile's content and defaulted being transformed by their formats
     *
     * @memberof ConfigDirectory
     * @instance
     * @async
     * @function read
     * @param { ?ConfigDirectoryReadOptions } options
     * @returns { Promise&lt;ConfigDirectory> } - This ConfigDirectory for chainability
     */
    ConfigDirectory.prototype.read = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var default_files, file, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        default_files = {};
                        if (this.default_files) {
                            for (file in this.default_files) {
                                default_files[path.resolve(this.directory_path, file)] = this.default_files[file];
                            }
                        }
                        return [4 /*yield*/, this._read_directory(this.directory_path, this.files, default_files, true, options)];
                    case 1:
                        result = _a.sent();
                        this.files = result.files;
                        this.defaulted = result.defaulted;
                        return [2 /*return*/, this];
                }
            });
        });
    };
    /**
     * Writes ConfigDirectory's ConfigFiles' contents after being transformed by their formats
     *
     * @memberof ConfigDirectory
     * @instance
     * @async
     * @function write
     * @returns { Promise&lt;ConfigDirectory> } - This ConfigDirectory for chainability
     */
    ConfigDirectory.prototype.write = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _i, file, configfile, error_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = [];
                        for (_b in this.files)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 1;
                    case 1:
                        if (!(_i &lt; _a.length)) return [3 /*break*/, 6];
                        file = _a[_i];
                        configfile = this.files[file];
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, configfile.write()];
                    case 3:
                        _c.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _c.sent();
                        throw error_1;
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/, this];
                }
            });
        });
    };
    ConfigDirectory.prototype._readdir = function (directory_path) {
        return new Promise(function (resolve, reject) {
            fs_1.readdir(directory_path, function (error, files) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(files);
                }
            });
        });
    };
    ConfigDirectory.prototype._is_directory = function (file_path) {
        return new Promise(function (resolve) {
            fs_1.stat(file_path, function (error, stats) {
                if (error) {
                    resolve(false);
                }
                else {
                    resolve(stats.isDirectory());
                }
            });
        });
    };
    ConfigDirectory.prototype._read_directory = function (directory_path, existing_configs, default_files, recursive, options) {
        return __awaiter(this, void 0, void 0, function () {
            var configfiles, files, defaulted, error_2, file, _i, files_1, file, config, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        configfiles = {};
                        defaulted = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._readdir(directory_path)];
                    case 2:
                        files = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _a.sent();
                        // Directory doesn't exist
                        files = [];
                        return [3 /*break*/, 4];
                    case 4:
                        // Map files to absolute file paths
                        files = files.map(function (file) { return path.resolve(directory_path, file); });
                        if (options &amp;&amp; options.only_read_defaults) {
                            // Remove non-default files
                            files = files.filter(function (file) { return default_files.hasOwnProperty(file); });
                        }
                        // Add default files
                        for (file in default_files) {
                            if (!files.includes(file)) {
                                files.push(file);
                            }
                        }
                        _i = 0, files_1 = files;
                        _a.label = 5;
                    case 5:
                        if (!(_i &lt; files_1.length)) return [3 /*break*/, 15];
                        file = files_1[_i];
                        config = void 0;
                        return [4 /*yield*/, this._is_directory(file)];
                    case 6:
                        if (!_a.sent()) return [3 /*break*/, 11];
                        if (!(options &amp;&amp; options.read_directories)) return [3 /*break*/, 9];
                        // Is there an existing ConfigDirectory instance?
                        if (existing_configs &amp;&amp; existing_configs[file] instanceof ConfigDirectory) {
                            // There is
                            config = existing_configs[file];
                        }
                        else {
                            // There isn't. Create a new instance
                            config = new ConfigDirectory(file, this.format);
                        }
                        if (!(options.recursive || recursive)) return [3 /*break*/, 8];
                        return [4 /*yield*/, this._read_directory(config.directory_path, config.files, null, false, options)];
                    case 7:
                        result = _a.sent();
                        config.files = result.files;
                        config.defaulted = result.defaulted;
                        _a.label = 8;
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 14];
                    case 10: return [3 /*break*/, 13];
                    case 11:
                        // Is there an existing ConfigFile instance?
                        if (existing_configs &amp;&amp; existing_configs[file] instanceof ConfigFile_1.ConfigFile) {
                            // There is
                            config = existing_configs[file];
                        }
                        else {
                            // There isn't. Create a new instance
                            config = new ConfigFile_1.ConfigFile(file, this.format);
                        }
                        // Read file
                        return [4 /*yield*/, config
                                .defaults(default_files ? default_files[file] : null, this.default_options)
                                .read(options ? { write_if_defaulted: options.write_if_defaulted } : null)];
                    case 12:
                        // Read file
                        _a.sent();
                        _a.label = 13;
                    case 13:
                        if (config.defaulted == true) {
                            defaulted = true;
                        }
                        configfiles[path.relative(directory_path, file)] = config;
                        _a.label = 14;
                    case 14:
                        _i++;
                        return [3 /*break*/, 5];
                    case 15: return [2 /*return*/, {
                            files: configfiles,
                            defaulted: defaulted
                        }];
                }
            });
        });
    };
    return ConfigDirectory;
}());
exports.ConfigDirectory = ConfigDirectory;
/**
 * @typedef ConfigDirectoryReadOptions
 * @property { ?boolean } only_read_defaults - Only read files with specified default content
 * @property { ?boolean } read_directories - Read directories
 * @property { ?boolean } recursive - Recursively read directories. Needs read_directories to work
 * @property { ?boolean } write_if_defaulted - Call write method if any of directory's files' contents were defaulted in any way after reading
 */
/**
* ConfigDirectory's ConfigFiles
*
* @memberof ConfigDirectory
* @instance
* @member { object } files
*/
/**
 * If any of directory's files' contents were defaulted in any way after reading
 *
 * @memberof ConfigDirectory
 * @instance
 * @member { boolean } defaulted
 */
/**
 * Absolute path to directory
 *
 * @memberof ConfigDirectory
 * @instance
 * @member { string } directory_path
 */
/**
 * Format responsible for data and content transformation. Passed when initializing a new ConfigFile when reading
 *
 * @memberof ConfigDirectory
 * @instance
 * @member { Format } format
 */
/**
 * Content each ConfigFile's format should default to when reading
 *
 * @memberof ConfigDirectory
 * @instance
 * @member {} default_content
 */
/**
 * Options telling format how to default content when reading
 *
 * @memberof ConfigDirectory
 * @instance
 * @member {} default_options
 */ 
//# sourceMappingURL=ConfigDirectory.js.map</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Mar 29 2019 02:11:01 GMT+0100 (GMT+01:00) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
